#include <Windows.h>
#include "Helper.h"


// https://github.com/vxunderground/VX-API/blob/main/String%20Manipulation/RfZeroMemory.cpp
VOID RfZeroMemory(PVOID Destination, SIZE_T Size)
{
	PULONG Dest = (PULONG)Destination;
	SIZE_T Count = Size / sizeof(ULONG);

	while (Count > 0)
	{
		*Dest = 0;
		Dest++;
		Count--;
	}

	return;
}


// https://github.com/MalwareApiLib/MalwareApiLibrary/blob/main/StringManagementLib/Strings.c#L469
SIZE_T CharStringToWCharString(PWCHAR Destination, PCHAR Source, SIZE_T MaximumAllowed)
{
	INT Length = (INT)MaximumAllowed;

	while (--Length >= 0)
	{
		if (!(*Destination++ = *Source++))
			return MaximumAllowed - Length - 1;
	}

	return MaximumAllowed - Length;
}



// https://github.com/MalwareApiLib/MalwareApiLibrary/blob/main/StringManagementLib/Strings.c#L69
INT StringCompareW(LPCWSTR String1, LPCWSTR String2)
{
	for (; *String1 == *String2; String1++, String2++)
	{
		if (*String1 == '\0')
			return 0;
	}

	return ((*(LPCWSTR)String1 < *(LPCWSTR)String2) ? -1 : +1);
}


// https://github.com/MalwareApiLib/MalwareApiLibrary/blob/main/StringManagementLib/Strings.c#L188
SIZE_T StringLengthA(LPCSTR String)
{
	LPCSTR String2;

	for (String2 = String; *String2; ++String2);

	return (String2 - String);
}

SIZE_T StringLengthW(LPCWSTR String)
{
	LPCWSTR String2;

	for (String2 = String; *String2; ++String2);

	return (String2 - String);
}

// https://github.com/MalwareApiLib/MalwareApiLibrary/blob/main/StringManagementLib/Strings.c#L20
PWCHAR CaplockStringW(PWCHAR Ptr)
{
	PWCHAR sv = Ptr;
	while (*sv != '\0')
	{
		if (*sv >= 'a' && *sv <= 'z')
			*sv = *sv - ('a' - 'A');

		sv++;
	}
	return Ptr;
}

// https://github.com/MalwareApiLib/MalwareApiLibrary/blob/main/StringManagementLib/Strings.c#L110
PWCHAR StringCopyW(PWCHAR String1, PWCHAR String2)
{
	PWCHAR p = String1;

	while ((*p++ = *String2++) != 0);

	return String1;
}

// https://github.com/MalwareApiLib/MalwareApiLibrary/blob/main/StringManagementLib/StringHashing.c#L200
UINT32 HashStringRotr32SubA(UINT32 Value, UINT Count)
{
	DWORD Mask = (CHAR_BIT * sizeof(Value) - 1);
	Count &= Mask;
#pragma warning( push )
#pragma warning( disable : 4146)
	return (Value >> Count) | (Value << ((-Count) & Mask));
#pragma warning( pop ) 
}

INT HashStringRotr32A(PCHAR String, INT Seed)
{
	INT Value = 0;

	for (INT Index = 0; Index < StringLengthA(String); Index++)
		Value = String[Index] + HashStringRotr32SubA(Value, Seed);

	return Value;
}

UINT32 HashStringRotr32SubW(UINT32 Value, UINT Count)
{
	DWORD Mask = (CHAR_BIT * sizeof(Value) - 1);
	Count &= Mask;
#pragma warning( push )
#pragma warning( disable : 4146)
	return (Value >> Count) | (Value << ((-Count) & Mask));
#pragma warning( pop ) 
}

INT HashStringRotr32W(PWCHAR String, INT Seed)
{
	INT Value = 0;

	for (INT Index = 0; Index < StringLengthW(String); Index++)
		Value = String[Index] + HashStringRotr32SubW(Value, Seed);

	return Value;
}


// https://github.com/MalwareApiLib/MalwareApiLibrary/blob/main/StringManagementLib/Strings.c#L58
INT StringCompareA(LPCSTR String1, LPCSTR String2)
{
	for (; *String1 == *String2; String1++, String2++)
	{
		if (*String1 == '\0')
			return 0;
	}

	return ((*(LPCSTR)String1 < *(LPCSTR)String2) ? -1 : +1);
}