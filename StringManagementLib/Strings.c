#include <Windows.h>
#include "Strings.h"
#include "StringManagment.h"

//------------------------------------------------------------------------------------------------------------------------------------
// https://github.com/vxunderground/VX-API/blob/main/String%20Manipulation/CaplockString.cpp
PCHAR CaplockStringA(PCHAR Ptr)
{
	PCHAR sv = Ptr;
	while (*sv != '\0')
	{
		if (*sv >= 'a' && *sv <= 'z')
			*sv = *sv - ('a' - 'A');

		sv++;
	}
	return Ptr;
}

PWCHAR CaplockStringW(PWCHAR Ptr)
{
	PWCHAR sv = Ptr;
	while (*sv != '\0')
	{
		if (*sv >= 'a' && *sv <= 'z')
			*sv = *sv - ('a' - 'A');

		sv++;
	}
	return Ptr;
}

//------------------------------------------------------------------------------------------------------------------------------------
//https://github.com/vxunderground/VX-API/blob/main/String%20Manipulation/SecureStringCopy.cpp

PCHAR SecureStringCopyA(PCHAR String1, LPCSTR String2, SIZE_T Size)
{
	PCHAR pChar = String1;

	while (Size-- && (*String1++ = *String2++) != '\0');

	return pChar;
}

PWCHAR SecureStringCopyW(PWCHAR String1, LPCWSTR String2, SIZE_T Size)
{
	PWCHAR pChar = String1;

	while (Size-- && (*String1++ = *String2++) != '\0');

	return pChar;
}


//------------------------------------------------------------------------------------------------------------------------------------
// https://github.com/vxunderground/VX-API/blob/main/String%20Manipulation/StringCompare.cpp

INT StringCompareA(LPCSTR String1, LPCSTR String2)
{
	for (; *String1 == *String2; String1++, String2++)
	{
		if (*String1 == '\0')
			return 0;
	}

	return ((*(LPCSTR)String1 < *(LPCSTR)String2) ? -1 : +1);
}

INT StringCompareW(LPCWSTR String1, LPCWSTR String2)
{
	for (; *String1 == *String2; String1++, String2++)
	{
		if (*String1 == '\0')
			return 0;
	}

	return ((*(LPCWSTR)String1 < *(LPCWSTR)String2) ? -1 : +1);
}

//------------------------------------------------------------------------------------------------------------------------------------
// https://github.com/vxunderground/VX-API/blob/main/String%20Manipulation/StringConcat.cpp


PWCHAR StringConcatW(PWCHAR String, PWCHAR String2)
{
	StringCopyW(&String[StringLengthW(String)], String2);

	return String;
}

PCHAR StringConcatA(PCHAR String, PCHAR String2)
{
	StringCopyA(&String[StringLengthA(String)], String2);

	return String;
}

//------------------------------------------------------------------------------------------------------------------------------------
// https://github.com/vxunderground/VX-API/blob/main/String%20Manipulation/StringCopy.cpp

PCHAR StringCopyA(PCHAR String1, PCHAR String2)
{
	PCHAR p = String1;

	while ((*p++ = *String2++) != 0);

	return String1;
}

PWCHAR StringCopyW(PWCHAR String1, PWCHAR String2)
{
	PWCHAR p = String1;

	while ((*p++ = *String2++) != 0);

	return String1;
}

//------------------------------------------------------------------------------------------------------------------------------------
// https://github.com/vxunderground/VX-API/blob/main/String%20Manipulation/StringFindSubstring.cpp
INT StringCompareStringRegionA(PCHAR String1, PCHAR String2, SIZE_T Count)
{
	UCHAR Block1, Block2;
	while (Count-- > 0)
	{
		Block1 = (UCHAR)*String1++;
		Block2 = (UCHAR)*String2++;

		if (Block1 != Block2)
			return Block1 - Block2;

		if (Block1 == '\0')
			return 0;
	}

	return 0;
}

INT StringCompareStringRegionW(PWCHAR String1, PWCHAR String2, SIZE_T Count)
{
	UCHAR Block1, Block2;
	while (Count-- > 0)
	{
		Block1 = (UCHAR)*String1++;
		Block2 = (UCHAR)*String2++;

		if (Block1 != Block2)
			return Block1 - Block2;

		if (Block1 == '\0')
			return 0;
	}

	return 0;
}


PCHAR StringFindSubstringA(PCHAR String1, PCHAR String2)
{
	PCHAR pPointer = String1;
	DWORD Length = (DWORD)StringLengthA(String2);

	for (; (pPointer = StringLocateCharA(pPointer, *String2)) != 0; pPointer++)
	{
		if (StringCompareStringRegionA(pPointer, String2, Length) == 0)
			return (PCHAR)pPointer;
	}

	return NULL;
}

PWCHAR StringFindSubstringW(PWCHAR String1, PWCHAR String2)
{
	PWCHAR pPointer = String1;
	DWORD Length = (DWORD)StringLengthW(String2);

	for (; (pPointer = StringLocateCharW(pPointer, *String2)) != 0; pPointer++)
	{
		if (StringCompareStringRegionW(pPointer, String2, Length) == 0)
			return (PWCHAR)pPointer;
	}

	return NULL;
}

//------------------------------------------------------------------------------------------------------------------------------------
// https://github.com/vxunderground/VX-API/blob/main/String%20Manipulation/StringLength.cpp
SIZE_T StringLengthA(LPCSTR String)
{
	LPCSTR String2;

	for (String2 = String; *String2; ++String2);

	return (String2 - String);
}

SIZE_T StringLengthW(LPCWSTR String)
{
	LPCWSTR String2;

	for (String2 = String; *String2; ++String2);

	return (String2 - String);
}

//------------------------------------------------------------------------------------------------------------------------------------
// https://github.com/vxunderground/VX-API/blob/main/String%20Manipulation/StringLocateChar.cpp
PCHAR StringLocateCharA(PCHAR String, INT Character)
{
	do
	{
		if (*String == Character)
			return (PCHAR)String;

	} while (*String++);

	return NULL;
}

PWCHAR StringLocateCharW(PWCHAR String, INT Character)
{
	do
	{
		if (*String == Character)
			return (PWCHAR)String;

	} while (*String++);

	return NULL;
}

//------------------------------------------------------------------------------------------------------------------------------------
// https://github.com/vxunderground/VX-API/blob/main/String%20Manipulation/StringRemoveSubstring.cpp



PVOID RfCopyMemory(PVOID Destination, CONST PVOID Source, SIZE_T Length)
{
	PBYTE D = (PBYTE)Destination;
	PBYTE S = (PBYTE)Source;

	while (Length--)
		*D++ = *S++;

	return Destination;
}


PCHAR StringRemoveSubstringA(PCHAR String, CONST PCHAR Substring)
{
	DWORD Length = (DWORD)StringLengthA(Substring);
	PCHAR pPointer = String;

	if (Length == 0)
		return NULL;

	while ((pPointer = StringFindSubstringA(pPointer, Substring)) != NULL)
		RfCopyMemory(pPointer, pPointer + Length, StringLengthA(pPointer + Length) + 1);

	return String;
}

PWCHAR StringRemoveSubstringW(PWCHAR String, CONST PWCHAR Substring)
{
	DWORD Length = (DWORD)StringLengthW(Substring);
	PWCHAR pPointer = String;

	if (Length == 0)
		return NULL;

	while ((pPointer = StringFindSubstringW(pPointer, Substring)) != NULL)
		RfCopyMemory(pPointer, pPointer + Length, StringLengthW(pPointer + Length) + 1);

	return String;
}

//------------------------------------------------------------------------------------------------------------------------------------
// https://github.com/vxunderground/VX-API/blob/main/String%20Manipulation/StringTerminateStringAtChar.cpp


PCHAR StringTerminateStringAtCharA(PCHAR String, INT Character)
{
	DWORD Length = (DWORD)StringLengthA(String);

	for (DWORD Index = 0; Index < Length; Index++)
	{
		if (String[Index] == Character)
		{
			String[Index] = '\0';
			return String;
		}
	}

	return NULL;
}

PWCHAR StringTerminateStringAtCharW(PWCHAR String, INT Character)
{
	DWORD Length = (DWORD)StringLengthW(String);

	for (DWORD Index = 0; Index < Length; Index++)
	{
		if (String[Index] == Character)
		{
			String[Index] = '\0';
			return String;
		}
	}

	return NULL;
}


//------------------------------------------------------------------------------------------------------------------------------------
// https://github.com/vxunderground/VX-API/blob/main/String%20Manipulation/StringToken.cpp



PCHAR StringTokenA(PCHAR String, CONST PCHAR Delim)
{
	PCHAR Last;
	PCHAR SpanP, Token;
	INT C, SC;

	if (String == NULL)
		return NULL;

CONTINUE:

	C = *String++;

	for (SpanP = (PCHAR)Delim; (SC = *SpanP++) != ERROR_SUCCESS;)
	{
		if (C == SC)
			goto CONTINUE;
	}

	if (C == ERROR_SUCCESS) { Last = NULL; return NULL; }

	Token = String - 1;

	for (;;)
	{
		C = *String++;
		SpanP = (PCHAR)Delim;

		do {
			if ((SC = *SpanP++) == C)
			{
				if (C == ERROR_SUCCESS)
					String = NULL;
				else
					String[-1] = '\0';

				Last = String;
				return Token;
			}
		} while (SC != ERROR_SUCCESS);
	}

	return NULL;

}

PWCHAR StringTokenW(PWCHAR String, CONST PWCHAR Delim)
{
	PWCHAR Last;
	PWCHAR SpanP, Token;
	INT C, SC;

	if (String == NULL)
		return NULL;

CONTINUE:

	C = *String++;

	for (SpanP = (PWCHAR)Delim; (SC = *SpanP++) != ERROR_SUCCESS;)
	{
		if (C == SC)
			goto CONTINUE;
	}

	if (C == ERROR_SUCCESS) { Last = NULL; return NULL; }

	Token = String - 1;

	for (;;)
	{
		C = *String++;
		SpanP = (PWCHAR)Delim;

		do {
			if ((SC = *SpanP++) == C)
			{
				if (C == ERROR_SUCCESS)
					String = NULL;
				else
					String[-1] = '\0';

				Last = String;
				return Token;
			}
		} while (SC != ERROR_SUCCESS);
	}

	return NULL;

}

//------------------------------------------------------------------------------------------------------------------------------------
// https://github.com/vxunderground/VX-API/blob/main/String%20Manipulation/Windows%20Unicode%20Structure/RtlInitEmptyUnicodeString.cpp


VOID RtlInitEmptyUnicodeString(PUNICODE_STRING UnicodeString, PWCHAR Buffer, USHORT BufferSize)
{
	UnicodeString->Length = 0;
	UnicodeString->MaximumLength = BufferSize;
	UnicodeString->Buffer = Buffer;

	return;
}


//------------------------------------------------------------------------------------------------------------------------------------
// https://github.com/vxunderground/VX-API/blob/main/String%20Manipulation/Windows%20Unicode%20Structure/RtlInitUnicodeString.cpp
VOID RtlInitUnicodeString(PUNICODE_STRING DestinationString, PCWSTR SourceString)
{
	SIZE_T DestSize;

	if (SourceString)
	{
		DestSize = StringLengthW(SourceString) * sizeof(WCHAR);
		DestinationString->Length = (USHORT)DestSize;
		DestinationString->MaximumLength = (USHORT)DestSize + sizeof(WCHAR);
	}
	else
	{
		DestinationString->Length = 0;
		DestinationString->MaximumLength = 0;
	}

	DestinationString->Buffer = (PWCHAR)SourceString;
}

//------------------------------------------------------------------------------------------------------------------------------------
// https://github.com/vxunderground/VX-API/blob/main/String%20Manipulation/String%20Conversion/CharArrayToByteArray.cpp

VOID CharArrayToByteArrayA(PCHAR Char, PBYTE Byte, DWORD Length)
{
	for (DWORD dwX = 0; dwX < Length; dwX++)
	{
		Byte[dwX] = (BYTE)Char[dwX];
	}
}

VOID CharArrayToByteArrayW(PWCHAR Char, PBYTE Byte, DWORD Length)
{
	for (DWORD dwX = 0; dwX < Length; dwX++)
	{
		Byte[dwX] = (BYTE)Char[dwX];
	}
}

//------------------------------------------------------------------------------------------------------------------------------------
// https://github.com/vxunderground/VX-API/blob/main/String%20Manipulation/String%20Conversion/CharStringToWCharString.cpp


SIZE_T CharStringToWCharString(PWCHAR Destination, PCHAR Source, SIZE_T MaximumAllowed)
{
	INT Length = (INT)MaximumAllowed;

	while (--Length >= 0)
	{
		if (!(*Destination++ = *Source++))
			return MaximumAllowed - Length - 1;
	}

	return MaximumAllowed - Length;
}

//------------------------------------------------------------------------------------------------------------------------------------
// https://github.com/vxunderground/VX-API/blob/main/String%20Manipulation/String%20Conversion/DecimalToAscii.cpp

DWORD DecimalToAsciiA(PCHAR String, LPDWORD dwArray, DWORD dwLength)
{
	DWORD dwX = ERROR_SUCCESS;

	if (String == NULL)
		return dwX;

	for (; dwX < dwLength; dwX++) { String[dwX] = (CHAR)dwArray[dwX]; }

	return dwX;
}

DWORD DecimalToAsciiW(PWCHAR String, LPDWORD dwArray, DWORD dwLength)
{
	DWORD dwX = ERROR_SUCCESS;

	if (String == NULL)
		return dwX;

	for (; dwX < dwLength; dwX++) { String[dwX] = (WCHAR)dwArray[dwX]; }

	return dwX;
}

//------------------------------------------------------------------------------------------------------------------------------------
// https://github.com/vxunderground/VX-API/blob/main/String%20Manipulation/String%20Conversion/WCharStringToCharString.cpp

SIZE_T WCharStringToCharString(PCHAR Destination, PWCHAR Source, SIZE_T MaximumAllowed)
{
	INT Length = (INT)MaximumAllowed;

	while (--Length >= 0)
	{
#pragma warning( push )
#pragma warning( disable : 4244)
		if (!(*Destination++ = *Source++))
			return MaximumAllowed - Length - 1;
#pragma warning( pop ) 
	}

	return MaximumAllowed - Length;
}
//------------------------------------------------------------------------------------------------------------------------------------
