#include <Windows.h>
#include "StringHashing.h"
#include "StringManagment.h"

//------------------------------------------------------------------------------------------------------------------------------------
// https://chromium.googlesource.com/chromium/src/base/+/master/third_party/superfasthash/superfasthash.c

typedef unsigned char      uint8_t;
typedef unsigned int       uint32_t;

#define Get16Bits(d) ((((uint32_t)(((const uint8_t *)(d))[1])) << 8)\
                       +(uint32_t)(((const uint8_t *)(d))[0]) )

//------------------------------------------------------------------------------------------------------------------------------------
// https://github.com/vxunderground/VX-API/blob/main/Cryptography%20Related/String%20Hashing/HashStringDjb2.cpp

DWORD HashStringDjb2A(PCHAR String)
{
	ULONG Hash = Djb2HashStringStruct.Hash;
	INT Seed = Djb2HashStringStruct.Seed;

	if (Hash == NULL) {
		Hash = 5381;
	} 
	
	if (Seed == NULL) {
		Seed = 4;
	}

	INT c;

	while (c = *String++)
		Hash = ((Hash << Seed) + Hash) + c;

	return Hash;
}

DWORD HashStringDjb2W(PWCHAR String)
{
	ULONG Hash = Djb2HashStringStruct.Hash;
	INT Seed = Djb2HashStringStruct.Seed;

	if (Hash == NULL) {
		Hash = 5381;
	}

	if (Seed == NULL) {
		Seed = 4;
	}

	INT c;

	while (c = *String++)
		Hash = ((Hash << Seed) + Hash) + c;

	return Hash;
}



//------------------------------------------------------------------------------------------------------------------------------------
// https://github.com/vxunderground/VX-API/blob/main/Cryptography%20Related/String%20Hashing/HashStringFowlerNollVoVariant1a.cpp

ULONG HashStringFowlerNollVoVariant1aA(PCHAR String)
{
	ULONG Hash = Variant1aHashStringStruct.Hash1;
	ULONG Hash2 = Variant1aHashStringStruct.Hash2;


	if (Hash == NULL) {
		Hash = 0x811c9dc5;
	}

	if (Hash2 == NULL) {
		Hash2 = 0x811c9dc5;
	}


	while (*String)
	{
		Hash ^= (UCHAR)*String++;
		Hash *= Hash2;
	}

	return Hash;
}

ULONG HashStringFowlerNollVoVariant1aW(PWCHAR String)
{
	ULONG Hash = Variant1aHashStringStruct.Hash1;
	ULONG Hash2 = Variant1aHashStringStruct.Hash2;

	if (Hash == NULL) {
		Hash = 0x811c9dc5;
	}

	if (Hash2 == NULL) {
		Hash2 = 0x811c9dc5;
	}

	while (*String)
	{
		Hash ^= (UCHAR)*String++;
		Hash *= Hash2;
	}

	return Hash;
}


//------------------------------------------------------------------------------------------------------------------------------------
// https://github.com/vxunderground/VX-API/blob/main/Cryptography%20Related/String%20Hashing/HashStringJenkinsOneAtATime32Bit.cpp

UINT32 HashStringJenkinsOneAtATime32BitA(PCHAR String)
{

	INT rNb1 = JenkinsHashStringStruct.rNb1, rNb2 = JenkinsHashStringStruct.rNb2,
		rNb3 = JenkinsHashStringStruct.rNb3, rNb4 = JenkinsHashStringStruct.rNb4,
		rNb5 = JenkinsHashStringStruct.rNb5;

	if (rNb1 == NULL || rNb2 == NULL || rNb3 == NULL || rNb4 == NULL || rNb5 == NULL) {
		rNb1 = 10, rNb2 = 6, rNb3 = 3, rNb4 = 11, rNb5 = 15;
	}

	SIZE_T Index = 0;
	UINT32 Hash = 0;
	SIZE_T Length = StringLengthA(String);

	while (Index != Length)
	{
		Hash += String[Index++];
		Hash += Hash << rNb1;
		Hash ^= Hash >> rNb2;
	}

	Hash += Hash << rNb3;
	Hash ^= Hash >> rNb4;
	Hash += Hash << rNb5;

	return Hash;
}

UINT32 HashStringJenkinsOneAtATime32BitW(PWCHAR String)
{
	INT rNb1 = JenkinsHashStringStruct.rNb1, rNb2 = JenkinsHashStringStruct.rNb2,
		rNb3 = JenkinsHashStringStruct.rNb3, rNb4 = JenkinsHashStringStruct.rNb4,
		rNb5 = JenkinsHashStringStruct.rNb5;

	if (rNb1 == NULL || rNb2 == NULL || rNb3 == NULL || rNb4 == NULL || rNb5 == NULL) {
		rNb1 = 10, rNb2 = 6, rNb3 = 3, rNb4 = 11, rNb5 = 15;
	}

	SIZE_T Index = 0;
	UINT32 Hash = 0;
	SIZE_T Length = StringLengthW(String);

	while (Index != Length)
	{
		Hash += String[Index++];
		Hash += Hash << rNb1;
		Hash ^= Hash >> rNb2;
	}

	Hash += Hash << rNb3;
	Hash ^= Hash >> rNb4;
	Hash += Hash << rNb5;

	return Hash;
}


//------------------------------------------------------------------------------------------------------------------------------------
// https://github.com/vxunderground/VX-API/blob/main/Cryptography%20Related/String%20Hashing/HashStringLoseLose.cpp

DWORD HashStringLoseLoseA(PCHAR String)
{
	ULONG Hash = 0;
	INT c;

	while (c = *String++)
		Hash += c;

	return Hash;
}

DWORD HashStringLoseLoseW(PWCHAR String)
{
	ULONG Hash = 0;
	INT c;

	while (c = *String++)
		Hash += c;

	return Hash;
}

//------------------------------------------------------------------------------------------------------------------------------------
// https://github.com/vxunderground/VX-API/blob/main/Cryptography%20Related/String%20Hashing/HashStringRotr32.cpp

UINT32 HashStringRotr32SubA(UINT32 Value, UINT Count)
{
	DWORD Mask = (CHAR_BIT * sizeof(Value) - 1);
	Count &= Mask;
#pragma warning( push )
#pragma warning( disable : 4146)
	return (Value >> Count) | (Value << ((-Count) & Mask));
#pragma warning( pop ) 
}

INT HashStringRotr32A(PCHAR String, INT Seed)
{
	INT Value = 0;

	for (INT Index = 0; Index < StringLengthA(String); Index++)
		Value = String[Index] + HashStringRotr32SubA(Value, Seed);

	return Value;
}

UINT32 HashStringRotr32SubW(UINT32 Value, UINT Count)
{
	DWORD Mask = (CHAR_BIT * sizeof(Value) - 1);
	Count &= Mask;
#pragma warning( push )
#pragma warning( disable : 4146)
	return (Value >> Count) | (Value << ((-Count) & Mask));
#pragma warning( pop ) 
}

INT HashStringRotr32W(PWCHAR String, INT Seed)
{
	INT Value = 0;

	for (INT Index = 0; Index < StringLengthW(String); Index++)
		Value = String[Index] + HashStringRotr32SubW(Value, Seed);

	return Value;
}

//------------------------------------------------------------------------------------------------------------------------------------
// https://github.com/vxunderground/VX-API/blob/main/Cryptography%20Related/String%20Hashing/HashStringSdbm.cpp

DWORD HashStringSdbmA(PCHAR String)
{
	INT rNb1 = SdbmHashStringStruct.rNb1, rNb2 = SdbmHashStringStruct.rNb2;
	if (rNb1 == NULL || rNb2 == NULL) {
		rNb1 = 6, rNb2 = 16;
	}

	ULONG Hash = 0;
	INT c;

	while (c = *String++)
		Hash = c + (Hash << rNb1) + (Hash << rNb2) - Hash;

	return Hash;
}

DWORD HashStringSdbmW(PWCHAR String)
{
	INT rNb1 = SdbmHashStringStruct.rNb1, rNb2 = SdbmHashStringStruct.rNb2;
	if (rNb1 == NULL || rNb2 == NULL) {
		rNb1 = 6, rNb2 = 16;
	}

	ULONG Hash = 0;
	INT c;

	while (c = *String++)
		Hash = c + (Hash << rNb1) + (Hash << rNb2) - Hash;

	return Hash;
}


//------------------------------------------------------------------------------------------------------------------------------------
// https://github.com/vxunderground/VX-API/blob/main/Cryptography%20Related/String%20Hashing/HashStringSuperFastHash.cpp

UINT32 HashStringSuperFastHashA(PCHAR String)
{


	INT rNb1 = FastHashStringStruct.rNb1, rNb2 = FastHashStringStruct.rNb2,
		rNb3 = FastHashStringStruct.rNb3, rNb4 = FastHashStringStruct.rNb4,
		rNb5 = FastHashStringStruct.rNb5, rNb6 = FastHashStringStruct.rNb6,
		rNb7 = FastHashStringStruct.rNb7, rNb8 = FastHashStringStruct.rNb8,
		rNb9 = FastHashStringStruct.rNb9, rNbA = FastHashStringStruct.rNbA,
		rNbB = FastHashStringStruct.rNbB;

	if (rNb1 == NULL || rNb2 == NULL || rNb3 == NULL || rNb4 == NULL || rNb5 == NULL || 
		rNb6 == NULL || rNb7 == NULL || rNb8 == NULL || rNb9 == NULL || rNbA == NULL ||
		rNbB == NULL ){

		rNb1 = 11, rNb2 = 16, rNb3 = 18, rNb4 = 17, rNb5 = 10, rNb6 = 1, rNb7 = 3, rNb8 = 5,
			rNb9 = 4, rNbA = 25, rNbB = 6;
	}



	INT Length = (INT)StringLengthA(String);
	UINT32 Hash = Length;
	INT Tmp = 0;

	INT Rem = Length & 3;
	Length >>= 2;

	for (; Length > 0; Length--)
	{
		Hash += Get16Bits(String);
		Tmp = (Get16Bits(String + 2) << rNb1) ^ Hash;
		Hash = (Hash << rNb2) ^ Tmp;
#pragma warning( push )
#pragma warning( disable : 6305)
		String += 2 * sizeof(UINT16);
#pragma warning( pop ) 
		Hash += Hash >> rNb2;
	}

	switch (Rem)
	{
	case 3:
	{
		Hash += Get16Bits(String);
		Hash ^= Hash << rNb2;
		Hash ^= ((UCHAR)String[sizeof(UINT16)]) << rNb3;
		Hash += Hash >> rNb1;
		break;
	}
	case 2:
	{
		Hash += Get16Bits(String);
		Hash ^= Hash << rNb1;
		Hash ^= Hash >> rNb4;
		break;
	}
	case 1:
	{
		Hash += (UCHAR)*String;
		Hash ^= Hash << rNb5;
		Hash += Hash >> rNb6;
	}
	}

	Hash ^= Hash << rNb7;
	Hash += Hash >> rNb8;
	Hash ^= Hash << rNb9;
	Hash += Hash >> rNb4;
	Hash ^= Hash << rNbA;
	Hash += Hash >> rNbB;

	return Hash;
}

UINT32 HashStringSuperFastHashW(PWCHAR String)
{

	INT rNb1 = FastHashStringStruct.rNb1, rNb2 = FastHashStringStruct.rNb2,
		rNb3 = FastHashStringStruct.rNb3, rNb4 = FastHashStringStruct.rNb4,
		rNb5 = FastHashStringStruct.rNb5, rNb6 = FastHashStringStruct.rNb6,
		rNb7 = FastHashStringStruct.rNb7, rNb8 = FastHashStringStruct.rNb8,
		rNb9 = FastHashStringStruct.rNb9, rNbA = FastHashStringStruct.rNbA,
		rNbB = FastHashStringStruct.rNbB;

	if (rNb1 == NULL || rNb2 == NULL || rNb3 == NULL || rNb4 == NULL || rNb5 == NULL ||
		rNb6 == NULL || rNb7 == NULL || rNb8 == NULL || rNb9 == NULL || rNbA == NULL ||
		rNbB == NULL) {

		rNb1 = 11, rNb2 = 16, rNb3 = 18, rNb4 = 17, rNb5 = 10, rNb6 = 1, rNb7 = 3, rNb8 = 5,
			rNb9 = 4, rNbA = 25, rNbB = 6;
	}


	INT Length = (INT)StringLengthW(String);
	UINT32 Hash = Length;
	INT Tmp = 0;

	INT Rem = Length & 3;
	Length >>= 2;

	for (; Length > 0; Length--)
	{
		Hash += Get16Bits(String);
		Tmp = (Get16Bits(String + 2) << rNb1) ^ Hash;
		Hash = (Hash << rNb2) ^ Tmp;
#pragma warning( push )
#pragma warning( disable : 6305)
		String += 2 * sizeof(UINT16);
#pragma warning( pop ) 
		Hash += Hash >> rNb1;
	}

	switch (Rem)
	{
	case 3:
	{
		Hash += Get16Bits(String);
		Hash ^= Hash << rNb2;
		Hash ^= ((UCHAR)String[sizeof(UINT16)]) << rNb3;
		Hash += Hash >> rNb1;
		break;
	}
	case 2:
	{
		Hash += Get16Bits(String);
		Hash ^= Hash << rNb1;
		Hash ^= Hash >> rNb4;
		break;
	}
	case 1:
	{
		Hash += (UCHAR)*String;
		Hash ^= Hash << rNb5;
		Hash += Hash >> rNb6;
	}
	}

	Hash ^= Hash << rNb7;
	Hash += Hash >> rNb8;
	Hash ^= Hash << rNb9;
	Hash += Hash >> rNb4;
	Hash ^= Hash << rNbA;
	Hash += Hash >> rNbB;

	return Hash;
}

//------------------------------------------------------------------------------------------------------------------------------------
// https://github.com/vxunderground/VX-API/blob/main/Cryptography%20Related/String%20Hashing/HashStringUnknownGenericHash1.cpp

INT HashStringUnknownGenericHash1A(PCHAR String)
{


	INT rNb1 = GenericHashStringStruct.rNb1, rNb2 = GenericHashStringStruct.rNb2;
	if (rNb1 == NULL || rNb2 == NULL) {
		rNb1 = 4, rNb2 = 24;
	}

	PCHAR Pointer;
	INT Generic;
	INT Hash = 0;

	for (Pointer = String; *Pointer != '\0'; Pointer++)
	{
		Hash = (Hash << rNb1) + (INT)(*Pointer);
		Generic = Hash & 0xF0000000L;

		if (Generic != 0)
			Hash = Hash ^ (Generic >> rNb2);

		Hash = Hash & ~Generic;
	}

	return Hash;
}

INT HashStringUnknownGenericHash1W(PWCHAR String)
{
	
	INT rNb1 = GenericHashStringStruct.rNb1, rNb2 = GenericHashStringStruct.rNb2;
	if (rNb1 == NULL || rNb2 == NULL) {
		rNb1 = 4, rNb2 = 24;
	}

	PWCHAR Pointer;
	INT Generic;
	INT Hash = 0;

	for (Pointer = String; *Pointer != '\0'; Pointer++)
	{
		Hash = (Hash << rNb1) + (INT)(*Pointer);
		Generic = Hash & 0xF0000000L;

		if (Generic != 0)
			Hash = Hash ^ (Generic >> rNb2);

		Hash = Hash & ~Generic;
	}

	return Hash;
}


//------------------------------------------------------------------------------------------------------------------------------------

